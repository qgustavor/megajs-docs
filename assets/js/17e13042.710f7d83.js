"use strict";(self.webpackChunkmegajs_docs=self.webpackChunkmegajs_docs||[]).push([[9266],{4353:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=t(4848),o=t(8453);const a={sidebar_position:7},s="Advanced usage",r={id:"tutorial/advanced",title:"Advanced usage",description:"Downloading shared files using account limits",source:"@site/versioned_docs/version-0.17/tutorial/advanced.md",sourceDirName:"tutorial",slug:"/tutorial/advanced",permalink:"/docs/0.17/tutorial/advanced",draft:!1,unlisted:!1,editUrl:"https://github.com/qgustavor/megajs-docs/tree/main/versioned_docs/version-0.17/tutorial/advanced.md",tags:[],version:"0.17",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Downloading files",permalink:"/docs/0.17/tutorial/downloading"},next:{title:"Security",permalink:"/docs/0.17/tutorial/security"}},l={},d=[{value:"Downloading shared files using account limits",id:"downloading-shared-files-using-account-limits",level:2},{value:"Setting request configuration",id:"setting-request-configuration",level:2},{value:"Resuming a download",id:"resuming-a-download",level:2},{value:"Downloading then decrypting",id:"downloading-then-decrypting",level:2},{value:"Encrypting then uploading",id:"encrypting-then-uploading",level:2},{value:"Uploading without encryption",id:"uploading-without-encryption",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"advanced-usage",children:"Advanced usage"}),"\n",(0,i.jsx)(n.h2,{id:"downloading-shared-files-using-account-limits",children:"Downloading shared files using account limits"}),"\n",(0,i.jsxs)(n.p,{children:["Files created with ",(0,i.jsx)(n.code,{children:"new File"})," and ",(0,i.jsx)(n.code,{children:"File.fromURL"})," by default use a non-logged API instance and can be quite limited. To work around those limits accounts can be used, so downloading will use the limits from those:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// First log in\nconst storage = new Storage(options, callback)\n\n// Wait for the callback then get a shared file\nconst sharedFile = File.fromURL(url)\n\n// Finally replace the non-logged API instance with the logged instance\nsharedFile.api = storage.api\n\n// Now downloading the shared file will use the limits from that account\n"})}),"\n",(0,i.jsx)(n.h2,{id:"setting-request-configuration",children:"Setting request configuration"}),"\n",(0,i.jsxs)(n.p,{children:["In version 0.xx ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/request",children:"request"})," is used to handle HTTP(s) connections with MEGA servers. It can be configured like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Get a File or Storage object\nlet file = File.fromURL(url)\nlet storage = new Storage(options, callback)\n\n// The request module can be acessed using:\nfile.api.requestModule\nstorage.api.requestModule\n\n// It can be overwritten, so if you need to set up a proxy\nfile.api.requestModule = file.api.requestModule.defaults({\n  proxy: 'your proxy url'\n})\n\n// Storage logins up automatically, so if you may want to disable autologin\nstorage = new Storage({ ..., autologin: false })\n// configure request like shown above then login\nstorage.login(callback)\n"})}),"\n",(0,i.jsx)(n.p,{children:"If possible use this to set up a user-agent."}),"\n",(0,i.jsx)(n.h2,{id:"resuming-a-download",children:"Resuming a download"}),"\n",(0,i.jsx)(n.p,{children:"When a download fails it will stop the stream you need to create other stream in order to resume it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let file = File.fromURL(url)\nlet filename = 'filename.ext'\n\nlet start = fs.statSync(filename).size\n\nfile.download({ start })\n  .pipe(fs.createWriteStream(filename, {\n    flags: 'r+', // <= set flags to prevent overwriting the file\n    start\n  }))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"downloading-then-decrypting",children:"Downloading then decrypting"}),"\n",(0,i.jsx)(n.p,{children:"If you want to download then decrypt, not the two at the same time, then do the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let file = File.fromURL(url)\n\n// Download it using cipher\nfile.download({ cipher: true })\n  .pipe(fs.createWriteStream('filename.ext.enc'))\n\n// Later decrypt it using decrypt\nfs.readFileStream('filename.ext.enc')\n  .pipe(decrypt('base64 file key'))\n  .pipe(fs.createWriteStream('filename.ext'))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I find hard someone having to do that, but maybe it's useful for someone as seems ",(0,i.jsx)(n.a,{href:"https://github.com/tonistiigi/mega",children:"tonistiigi"})," supported it (by exporting the ",(0,i.jsx)(n.code,{children:"decrypt"})," function)."]}),"\n",(0,i.jsx)(n.h2,{id:"encrypting-then-uploading",children:"Encrypting then uploading"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let encryptStream = encrypt()\nfs.readFileStream('filename.ext')\n  .pipe(encryptStream)\n  .pipe(fs.createWriteStream('filename.ext.enc'))\n\n// Get the generated key\nencryptStream.on('end', () => {\n  console.log(encryptStream.key.toString('hex'))\n})\n\n// Later upload the encrypted file\nlet storage = new Storage(options, callback)\n\n// Wait for callback, then:\nstorage.upload({\n  uploadCiphertext: true,\n  key: Buffer.from('key from console.log', 'hex')\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/tonistiigi/mega",children:"tonistiigi's mega"})," also exported an ",(0,i.jsx)(n.code,{children:"encrypt"})," function, so that's how you can use it. Do ",(0,i.jsx)(n.strong,{children:"not"})," forget the ",(0,i.jsx)(n.code,{children:"size"})," option when uploading!"]}),"\n",(0,i.jsx)(n.h2,{id:"uploading-without-encryption",children:"Uploading without encryption"}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["This code does not work anymore due to changes in MEGA. For more info ",(0,i.jsx)(n.a,{href:"https://github.com/qgustavor/mega/discussions/108",children:"check this discussion"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"Make MEGA work like any other file hosting service:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let storage = new Storage(options, callback)\n\n// Wait for callback, then:\nstorage.upload({\n  uploadCiphertext: true,\n  // This key will be used to encrypt the attributes\n  // Avoid reusing keys (like using `Buffer.alloc(32)`)\n  // as seems MEGA does some kind of caching on those\n  key: crypto.randomBytes(32)\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To download do the ",(0,i.jsx)(n.a,{href:"#downloading-then-decrypting",children:'"Downloading then decrypting"'})," steps. Do ",(0,i.jsx)(n.strong,{children:"not"})," forget the ",(0,i.jsx)(n.code,{children:"size"})," option when uploading!"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);